from advent_utils import AdventSolution, AdventResult, unwrap_or
from collections import Counter
from utils import Span
import sys

alias CardType = DType.uint8


struct HandMode:
    alias First = HandMode(1)
    alias Second = HandMode(2)
    var value: UInt8

    fn __init__(inout self, value: UInt8):
        self.value = value

    fn __eq__(self, other: HandMode) -> Bool:
        return self.value == other.value


@value
struct Hand[mode: HandMode](ComparableCollectionElement):
    alias type = SIMD[CardType, 8]
    var value: Self.type
    var level: UInt8
    var bid: UInt32

    fn __init__(inout self, s: String):
        space_pos = s.find(" ")
        self.bid = parse_int(s[space_pos + 1 :])
        self.value = Self.type()

        @parameter
        for idx in range(5):
            self.value[idx] = Card[mode](s[idx]).value

        self.level = 1
        self._calc_level(s)

    fn _calc_level(inout self, s: String):
        chars = List(s[0], s[1], s[2], s[3], s[4])
        self.level = 1
        cnt = Counter(chars)

        @parameter
        if mode == HandMode.First:
            for k in cnt.values():
                self.level += k[] ** 2
            return

        val = cnt.most_common(1)[0]._value
        try:
            j_val = cnt.pop("J")
            cnt[val] += j_val
        except:
            pass

        for k in cnt.values():
            self.level += k[] ** 2

    fn __eq__(self, other: Self) -> Bool:
        return (self.value == other.value).reduce_and()

    fn __ne__(self, other: Self) -> Bool:
        return not self == other

    fn __gt__(self, other: Self) -> Bool:
        if self.level > other.level:
            return True
        if self.level < other.level:
            return False

        @parameter
        for i in range(5):
            if self.value[i] > other.value[i]:
                return True
            if self.value[i] < other.value[i]:
                return False

        return False

    fn __lt__(self, other: Self) -> Bool:
        if self.level < other.level:
            return True
        if self.level > other.level:
            return False

        @parameter
        for i in range(5):
            if self.value[i] < other.value[i]:
                return True
            if self.value[i] > other.value[i]:
                return False

        return False

    fn __ge__(self, other: Self) -> Bool:
        return self == other or self > other

    fn __le__(self, other: Self) -> Bool:
        return self == other or self < other


@register_passable("trivial")
struct Card[mode: HandMode]:
    var value: Scalar[CardType]
    alias A = Self(14)
    alias K = Self(13)
    alias Q = Self(12)
    alias J = Self(11)
    alias T = Self(10)

    fn __init__(inout self, v: Int):
        self.value = v

    fn __init__(inout self, v: String):
        if v == "A":
            self = Self.A
        elif v == "K":
            self = Self.K
        elif v == "Q":
            self = Self.Q
        elif v == "J":

            @parameter
            if mode == HandMode.First:
                self = Self.J
            else:
                self = 1
        elif v == "T":
            self = Self.T
        else:
            self = parse_int(v)
        return


fn parse_int(string: String) -> Int:
    try:
        return int(string)
    except:
        print("Error parsing int")
        sys.exit(1)
        return 0


struct Solution(AdventSolution):
    alias Hand1 = Hand[HandMode.First]
    alias Hand2 = Hand[HandMode.Second]

    @staticmethod
    fn part_1(lines: List[String]) -> AdventResult:
        cards = List[Self.Hand1]()
        for line in lines:
            cards.append(line[])

        total = 0

        sort(cards)
        for idx in range(len(cards)):
            total += (idx + 1) * int(cards[idx].bid)

        return total

    @staticmethod
    fn part_2(lines: List[String]) -> AdventResult:
        cards = List[Self.Hand2]()
        for line in lines:
            cards.append(line[])

        total = 0

        sort(cards)
        for idx in range(len(cards)):
            total += (idx + 1) * int(cards[idx].bid)

        return total
