from advent_utils import AdventSolution, AdventResult, unwrap_or
from collections import Counter
import sys

alias CardType = DType.uint8


@register_passable("trivial")
struct Hand:
    alias type = SIMD[CardType, 8]
    var value: Self.type
    var level: UInt8
    var bid: UInt32

    fn __init__(inout self, s: String):
        space_pos = s.find(" ")
        self.bid = parse_int(s[space_pos + 1 :])

        self.value = Hand.type()
        ctr = Counter(s[:space_pos])
        self.level = 1

        for k in ctr.values():
            self.level *= k[]

        @parameter
        for idx in range(5):
            self.value[idx] = Card(s[idx]).value

        print(
            "Card:", self.value, "with bid:", self.bid, "and level:", self.level
        )


@register_passable("trivial")
struct Card:
    var value: Scalar[CardType]
    alias A = Self(14)
    alias K = Self(13)
    alias Q = Self(12)
    alias J = Self(11)
    alias T = Self(10)

    fn __init__(inout self, v: Int):
        self.value = v

    fn __init__(inout self, v: String):
        if v == "A":
            self = Self.A
        if v == "K":
            self = Self.K
        if v == "Q":
            self = Self.Q
        if v == "J":
            self = Self.J
        if v == "T":
            self = Self.T
        else:
            self = parse_int(v)


fn parse_int(string: String) -> Int:
    try:
        return int(string)
    except:
        print("Error parsing int")
        sys.exit(1)
        return 0


@parameter
fn rank_hand(lhs: Hand, rhs: Hand) -> Bool:
    # Create a simd to represent the count of each element.
    if lhs.level > rhs.level:
        return True
    if lhs.level < rhs.level:
        return False

    @parameter
    for i in range(5):
        if lhs.value[i] > rhs.value[i]:
            return True
        if lhs.value[i] < rhs.value[i]:
            return False

    print("Equals!!")
    return True


struct Solution(AdventSolution):
    @staticmethod
    fn part_1(lines: List[String]) -> AdventResult:
        cards = List[Hand]()
        for line in lines:
            cards.append(line[])
        sort[rank_hand](cards)
        return 0

    @staticmethod
    fn part_2(lines: List[String]) -> AdventResult:
        return 0
